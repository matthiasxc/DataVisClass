<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <link rel="stylesheet" type="text/css" href="/html/css/phone.css" />
        <title>Windows Phone Processing Sketch</title>
    </head>
   <body>
       <!-- We'll add our processing sketch to this canvas -->
        <canvas id="canvasRoot" width="480" height="800"></canvas>

       <!-- This is the version of processing designed to work inside a Windows RT and
           IE 10 environment (includes things like multi-touch events) -->
        <

       <!-- There are two ways to create a processing sketch.
           The first is to write the sketch in traditional Javascript. 
           There is an example in the sketch seen commented out scrip below. -->

        <!--       <script src="js/sketch_sample.js" ></script>
               -->
       <script src="js/processing.js" ></script>
       <script src="js/sketchProcessing.js" ></script>

       <!-- The second way to create a processing sketch is to use standard
           Processing syntax within a processing script that points to our canvas.
           -->
        <script type="text/processing" data-processing-target="canvasRoot">
        
        int totalDots = 30;
        Dot[] dots = new Dot[totalDots];
        
        // Define our sketch canvas to fill our canvas element
        // The size of the viewport is 
        int width = 480;
        int height = 800;
        color fillColor;
        float diameter = 20.0;
        
        void setup() {
            // DEFINE THE STAGE
            size(width, height);
            // THE SAME FILL IS USED FOR ALL DOTS
            fillColor = color(255, 0, 0);
            fill(fillColor);
            noStroke();
            // CREATE A COLLECTION OF DOTS
            for (int i = 0; i < totalDots; i++) {
                Dot d = new Dot();
                d.x = random(width);
                d.y = random(height);
                d.vx = random(2.0) - 1.0;
                d.vy = random(2.0) - 1.0;
                dots[i] = d;
            }
            background(0);
        };
        
        void draw() {
            fill(0, 25);
            rect(0, 0, width, height);
        
            float r = 255;
            float g = 255;
            float b = 128;
        
            for (int i = 0; i < totalDots; i++) {
                r = map(dots[i].x, 0, width, 0, 128);
                g = map(dots[i].y, 0, height, 0, 128);
                fill(r, g, b);
                dots[i].update();                      
                ellipse(dots[i].x, dots[i].y, diameter, diameter);
            }
        };
        
        class Dot {
            float x = 0.0;
            float y = 0.0;
            float vx = 0.0;
            float vy = 0.0;   

            void update(){
                this.vx += random(2.0) - 1.0;
                this.vx *= .96;
                this.vy += random(2.0) - 1.0;
                this.vy *= .96;
                // update the position
                this.x += this.vx;
                this.y += this.vy;
                // handle boundary collision
                if (this.x > width){ this.x = width; this.vx *= -1.0; }
                if (this.x < 0){ this.x = 0; this.vx *= -1.0; }
                if (this.y > height){ this.y = height; this.vy *= -1.0; }
                if (this.y < 0) { this.y = 0; this.vy *= -1.0; }                  
            }
        }  
        
    </script>
    </body>
</html>