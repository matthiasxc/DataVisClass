<!DOCTYPE html>
<html>
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <link rel="stylesheet" type="text/css" href="/html/css/phone.css" />
        <title>Windows Phone Processing Sketch</title>
    </head>
   <body>
       <!-- We'll add our processing sketch to this canvas -->
        <canvas id="canvasRoot" width="480" height="800"></canvas>

       <!-- This is the version of processing designed to work inside a Windows RT and
           IE 10 environment (includes things like multi-touch events) -->
       
       <!-- There are two ways to create a processing sketch.
           The first is to write the sketch in traditional Javascript. 
           There is an example in the sketch seen commented out scrip below. -->

        <!--       <script src="js/sketch_sample.js" ></script>
               -->
       <script src="js/processing.js" ></script>

       <!-- The second way to create a processing sketch is to use standard
           Processing syntax within a processing script that points to our canvas.
           -->
      <script type="text/processing" data-processing-target="canvasRoot">
        
        /* @pjs preload="helloworld.jpg"; */ 
        float m = millis();

        PImage topBooks;

        Chapter[] chapters;
        Narrator[] povs = new Narrator[27];
        Houses[] houseCume = new Houses[8];
        Book[] bookTotals = new Book[5];

        int width = 1200;
        int height = 640;
        color fillColor;
        float diameter = 10.0;
        
        // 50 pixel height for book, 50 for chapter
        // 50 pixel height for pov, 50 for house
        // 350 for curve

        // ratio -> how many pages per pixel
        float ratio = 5;
        
        // defined colors
        color miscColor = color(95, 87, 133);
        color starkColor = color(73, 133, 141);
        color targColor = color(225, 65, 16);
        color nightColor = color(29, 40, 56);
        color lannisterColor = color(182, 126, 37);
        color baratheonColor = color(97, 8, 0);
        color greyjoyColor = color(107, 118, 84);
        color martellColor = color(195, 176, 80);

        void setup() {            
            // DEFINE THE STAGE
            size(width, height);
            fillColor = color(255, 0, 0);
            fill(fillColor);
            noStroke();
            
            topBooks = loadImage("topGotBanner.jpg");
           
            // Preload all the data
            for(int i = 0; i < povs.length; i++){
                povs[i] = new Narrator();
            }

            for(int i = 0; i < houseCume.length; i++){
                houseCume[i] = new Houses();
            }

            for(int i = 0; i < bookTotals.length; i++){
                bookTotals[i] = new Book();
            }

            //println("common 1");
            String lines[] = loadStrings("GOT_Data.csv");
            //println("there are " + lines.length + " lines");
            chapters = new Chapter[lines.length - 1];

            // Parse the raw chapter data
            for(int i  = 1; i < lines.length; i++){
                String[] values = split(lines[i], ',');
                Chapter c = new Chapter();
                c.book = values[0];
                c.character = values[1];
                c.startPage = parseFloat(values[2]);
                c.endPage = parseFloat(values[3]);
                c.pageCount = parseFloat(values[4]);
                chapters[i - 1] = c;
            }
            sortHouses();

            // Parse data into narrator info
            int charCount = 0;
            for(int i = 0; i < chapters.length; i++){
                Chapter c = chapters[i];
                boolean povLogged = false;
                // See if that character has already been logged
                for(int k = 0; k < povs.length; k++){
                    if(c.character == povs[k].name){
                        povs[k].pages = povs[k].pages + c.pageCount;
                        povLogged = true;
                    }
                }
                // otherwise add that character
                if(!povLogged){
                    povs[charCount].name = c.character;
                    povs[charCount].house = c.house;
                    povs[charCount].houseColor = c.houseColor;
                    povs[charCount].pages = c.pageCount;
                    povs[charCount].hasSigil = c.hasSigil;
                    if(c.hasSigil){                        
                        povs[charCount].sigil = c.sigil;
                    }    
                  charCount++;
                }
            }

            // Parse data into house info
            int houseCount = 0;
            for(int i = 0; i < povs.length; i++){
                Narrator n = povs[i];
                boolean houseLogged = false;
                // See if that house has already been logged
                for(int k = 0; k < houseCume.length; k++){
                    if(n.house == houseCume[k].house){
                        houseCume[k].pages = houseCume[k].pages + n.pages;
                        houseLogged = true;
                    }
                }
                // otherwise add that book
                if(!houseLogged){
                    houseCume[houseCount].house = n.house;
                    houseCume[houseCount].pages = n.pages;
                    houseCume[houseCount].houseColor = n.houseColor;                    
                    houseCume[houseCount].hasSigil = n.hasSigil;
                    if(n.hasSigil){                        
                        houseCume[houseCount].sigilImg = loadImage(n.sigil, "png");
                    }
                    houseCount++;
                }
                         
            }
            
            Houses miscHolder;
            for(int i = 0; i < houseCume.length; i++){
                if(i == 0){
                    miscHolder = houseCume[0];
                } else{
                    houseCume[i-1] = houseCume[i];
                }
            }
            houseCume[houseCume.length-1] = miscHolder;

          for(int i = 0; i < houseCume.length; i++){
                   //println(houseCume[i].house + " : " + houseCume[i].pages + " pages");
            }
          for(int i = 0; i < povs.length; i++){
                   //println(povs[i].name + " : " + povs[i].pages + " pages");
            }
            // Parse data into book info
            int bookCount = 0;
            for(int i = 0; i < chapters.length; i++){
                Chapter c = chapters[i];
                boolean bookLogged = false;
                // See if that character has already been logged
                for(int k = 0; k < bookTotals.length; k++){
                    if(c.book == bookTotals[k].bookName){
                        bookTotals[k].pages = bookTotals[k].pages + c.pageCount;
                        bookTotals[k].chapters++;
                        bookLogged = true;
                    }
                }
                // otherwise add that character
                if(!bookLogged){
                    bookTotals[bookCount].bookName = c.book;
                    bookTotals[bookCount].pages = c.pageCount;
                    bookTotals[bookCount].chapters++;
                    if(c.book == "A Storm of Swords"){
                        bookTotals[bookCount].bookColor = color(92, 159, 106);
                    } else if (c.book == "A Clash of Kings"){
                        bookTotals[bookCount].bookColor = color(193, 153, 55);
                    } else if (c.book == "A Game of Thrones"){
                        bookTotals[bookCount].bookColor = color(3, 120, 173);
                    } else if (c.book == "A Feast for Crows"){
                        bookTotals[bookCount].bookColor = color(178, 46, 33);
                    } else if (c.book == "A Dance with Dragons"){
                        bookTotals[bookCount].bookColor = color(200, 200, 255);
                    }
                    bookCount++;
                }
            }
            
            for(int i = 0; i < bookTotals.length; i++){
                   // println(bookTotals[i].bookName + " : " + bookTotals[i].pages + " pages, " + bookTotals[i].chapters + " chapters");
            }
            
            background(255, 255, 255);
            initialDraw();
            //println(millis() + " millisecond");
        };
        
        boolean isReadyForImageDraw = false;
        boolean initialImageDraw = false;
        void draw() {
            //fill(0, 25);
            //rect(0, 0, width, height);      
            //image(topBooks, 0, 0);
          if(isReadyForImageDraw && !initialImageDraw){            
              image(topBooks, 20, 4);
              initialImageDraw = true;
              //println("drawing sigils");
              for(int i = 0; i < houseCume.length; i++){
                if(houseCume[i].hasSigil){
                    image(houseCume[i].sigilImg, houseCume[i].startPixel + 2, 480);
                }
              }
          }
        };

        // Drawing guides
        Chapter focusChapter = new Chapter();
        Narrator focusNarrator = new Narrator();
        House focusHouse = new Houses();
        Book focusBook = new Book();

        // the focus target can be BOOK, CHAPTER, POV, HOUSE
        // or ""
        String focusTarget = "";

        void mouseMoved(){
            // are they mousing over the book section?
            boolean updated = false;
            if(mouseY > 4 && mouseY < 84){
                for(int i = 0; i < bookTotals.length; i++){
                    if(mouseX >= bookTotals[i].startPixel && mouseX < bookTotals[i].endPixel){
                        //println(bookTotals[i].bookName);
                        if(bookTotals[i].bookName != focusBook.bookName || focusTarget != "BOOK"){
                            updated = true;
                            focusTarget = "BOOK";
                            focusBook = bookTotals[i];
                            renderBook();
                        }
                    }
                }
            } else if (mouseY >= 460 && mouseY < 476){
                // if they are mousing over the povs section
                for(i = 0; i < povs.length; i++){
                    if(mouseX >= povs[i].startPixel && mouseX < povs[i].endPixel){
                        //println(povs[i].name + ": " + povs[i].pages);
                        if(povs[i].name != focusNarrator.name || focusTarget != "POV"){
                            updated = true;
                            focusTarget = "POV";
                            focusNarrator = povs[i];
                            renderPOV();
                        }                   
                    }
                }
            } else if (mouseY >= 476 && mouseY < 530){
                // if they are mousing over the houses section
                for(i = 0; i < houseCume.length; i++){
                    if(mouseX >= houseCume[i].startPixel && mouseX < houseCume[i].endPixel){
                        //println(houseCume[i].house + ": " + houseCume[i].pages);                    
                        if(houseCume[i].house != focusHouse.house || focusTarget!= "HOUSE"){
                            updated = true;
                            focusTarget = "HOUSE";
                            focusHouse = houseCume[i];
                            renderHouse();                        
                        }     
                    }
                }
            }
            else {
                if(focusTarget != ""){
                    renderNormal();                    
                    focusTarget = "";   
                }
            }
        }
        //string book = "";
        //  string character = "";
        //  string house = "";
        //  boolean isSelected = false;
        //  boolean isSubtle = false;
        void renderBook(){
          //println("rendering book");
          resetCurves();
          for(int i = 0; i < chapters.length; i++){
            if(chapters[i].book == focusBook.bookName){
                chapters[i].isSelected = true;
            } else {
                chapters[i].isSubtle = true;
            }
            chapters[i].draw();
          }
        }

        void renderHouse(){
          //println("rendering House");
          resetCurves();
          for(int i = 0; i < chapters.length; i++){
            if(chapters[i].house == focusHouse.house){
                chapters[i].isSelected = true;
            } else {
                chapters[i].isSubtle = true;
            }
            chapters[i].draw(); 
          }
        }

        void renderPOV(){
          //println("rendering POV");
          resetCurves();
          for(int i = 0; i < chapters.length; i++){
            if(chapters[i].character == focusNarrator.name){
                chapters[i].isSelected = true;
            } else {
                chapters[i].isSubtle = true;
            }
            chapters[i].draw(); 
          }
        }

        void renderNormal(){
          //println("rendering House");
          resetCurves();
          for(int i = 0; i < chapters.length; i++){
            chapters[i].isSelected = false;
            chapters[i].isSubtle = false;
            chapters[i].draw();            
          }
        }

        




        void resetCurves(){
            fill(255);
            noStroke();
            rect(20, 88, 1000, 372);
              for(int i = 0; i < chapters.length; i++){
                chapters[i].isSelected = false;
                chapters[i].isSubtle = false;           
              }
        }

        void initialDraw(){
            // Draw the books
            //println("in draw");
            float leftAlign = 20;
            float currentPixel = leftAlign;
            noStroke();
            rectMode(CORNER);
            for(int i = 0; i < bookTotals.length; i++){
                fill(bookTotals[i].bookColor);
                bookTotals[i].width = bookTotals[i].pages/ratio;
                bookTotals[i].startPixel = currentPixel;
                bookTotals[i].endPixel = currentPixel + bookTotals[i].width;
                rect(currentPixel, 20, bookTotals[i].width, 50);
                currentPixel = currentPixel + bookTotals[i].width + 6;
            }
            currentPixel = leftAlign;
            
            
            // Draw the chapters
            String curBook = "A Game of Thrones";
            for(int i = 0; i < chapters.length; i++){
                if(curBook != chapters[i].book){
                    currentPixel = currentPixel + 6;
                }
                curBook = chapters[i].book;
                fill(chapters[i].houseColor);
                chapters[i].width = chapters[i].pageCount / ratio;
                chapters[i].startPixel = currentPixel;
                chapters[i].endPixel = currentPixel + chapters[i].width;
                //rect(currentPixel, 74, chapters[i].width + 1, 30);
                if(i != 0){
                    //println(chapters[i-1].character + "->" + chapters[i].character + " = " + chapters[i-1].endPixel + "->" + chapters[i].startPixel);
                }
                currentPixel = currentPixel + chapters[i].width;
            }
            currentPixel = leftAlign;
            // Draw the houses + Characters 
            for(int i = 0; i < houseCume.length; i++){
                double houseStart = currentPixel;                
                fill(houseCume[i].houseColor);
                //println(red(houseCume[i].houseColor) + "," + green(houseCume[i].houseColor) + "," + blue(houseCume[i].houseColor));
                houseCume[i].width = houseCume[i].pages / ratio;
                houseCume[i].startPixel = currentPixel;
                houseCume[i].endPixel = currentPixel + houseCume[i].width;
                rect(currentPixel, 476, houseCume[i].width, 70);
                strokeWeight(1);
                stroke(255);
                int narratorCount = 0;
                for(int k = 0; k < povs.length; k++){
                    if(povs[k].house == houseCume[i].house){
                        //println(povs[k].name  + ": " + povs[k].pages);
                        povs[k].width = povs[k].pages / ratio;
                        
                        povs[k].startPixel = houseStart;
                        povs[k].endPixel = houseStart + povs[k].width;
                        if(narratorCount == 0){
                            houseStart = houseStart - 1;
                        }
                        rect(houseStart, 460, povs[k].width, 16);
                        houseStart = houseStart + povs[k].width;
                        narratorCount = narratorCount + 1;
                    }
                }
                
                noStroke();
                currentPixel = currentPixel + houseCume[i].width + 3;
            }

            noFill();
            strokeCap(SQUARE);
            // Calculate the curves
            for(int i = 0; i < chapters.length; i++){
                for(int k = povs.length - 1; k >= 0; k--){
                    if(chapters[i].character == povs[k].name){
                        //color hC = povs[k].houseColor;
                        //stroke(povs[k].houseColor);
                        //stroke(red(hC), green(hC), blue(hC), 80);
                        //strokeWeight(chapters[i].width);
                        chapters[i].curveEnd = povs[k].startPixel + povs[k].curveHolder; 
                        povs[k].curveHolder = povs[k].curveHolder + chapters[i].width;
                        //float sp = chapters[i].startPixel + (.5 * chapters[i].width);
                        //float ep = chapters[i].curveEnd + (.5 * chapters[i].width);
                        //bezier(sp, 110, sp, 275, ep, 275, ep, 462); 
                        //bezier(chapters[i].startPixel, 104, chapters[i].startPixel, 275, chapters[i].curveEnd, 275, chapters[i].curveEnd, 462); 
                        chapters[i].draw();
                    }
                }
            }
            isReadyForImageDraw = true;
        };
        
        

        class Chapter {
          string book = "";
          string character = "";
          string house = "";
          boolean isSelected = false;
          boolean isSubtle = false;
          color houseColor = new color(0,0,0);
          float startPage = 0.0;
          float endPage = 0.0;
          float pageCount = 0.0;
          float width = 0.0;
          float startPixel = 0.0;
          float endPixel = 0.0; 
          float curveEnd = 0.0;
          float startOpacity = 0.0;
          float endOpacity = 0.0;
          float targetOpacity = 0.0;
          boolean hasSigil = true;
          string sigil; 

          void draw(){
            //println("draw started");             
            if(isSelected) {
                targetOpacity = 180;
            } else if (isSubtle) {
                targetOpacity = 20;
            } else {
                targetOpacity = 80;
            }
            noFill();
            color houseOpacity = color(red(houseColor), green(houseColor), blue(houseColor), targetOpacity);
            stroke(houseOpacity);
            //println(red(houseColor)+ "," +green(houseColor)+ "," +blue(houseColor)+ "," +targetOpacity);
            strokeWeight(width);
            float sp = startPixel + (.5 * width);
            float ep = curveEnd + (.5 * width);
            bezier(sp, 88, sp, 275, ep, 275, ep, 460);
            //noStroke();
            //fill(houseOpacity)
            //rect(sp, 88, width, 12);
          }

          void setFinal(){
            if(isSelected) {
                targetOpacity = 180;
            } else if (isSubtle) {
                targetOpacity = 20;
            } else {
                targetOpactiy = 80;
            }
          }
        }
        
        // Animation elements
        // First, the standard animation length (in frames)
        float aniFrames = 10.0;
        float curFrame = 0.0;

        double transition(float startO, float endO){
        }

        class Narrator{
          string name = "";
          string house ="";
          color houseColor = new color(0,0,0);
          float pages = 0.0;
          float width = 0.0;
          float startPixel = 0.0;
          float endPixel = 0.0;
          float curveHolder = 0.0;
          boolean hasSigil = true;
          string sigil;
          PImage avatar;
        }

        class Houses{
          string house = "";
          color houseColor = new color(0,0,0);
          float pages = 0.0;
          float width = 0.0;
          float startPixel = 0.0;
          float endPixel = 0.0;
          boolean hasSigil = true;          
          PImage sigilImg;
          //if(n.hasSigil){
          //  houseCume[houseCount].sigilImg = loadImage(n.sigil);
        }

        class Book{
            string bookName = "";
            color bookColor = color(0,0,0);
            float pages = 0.0;
            float width = 0.0;
            float povs = 0.0;
            float chapters = 0.0;
            float startPixel = 0.0;
            float endPixel = 0.0;            
        }

        void sortHouses(){
          for(int i = 0; i < chapters.length; i++)
          {
            Chapter curChap = chapters[i];
            switch(curChap.character){
                case "Aeron Greyjoy":
                    curChap.house = "Greyjoy";
                    break;
                case "Asha Greyjoy":
                    curChap.house = "Greyjoy";
                    break;
                case "Asha":
                    curChap.house = "Greyjoy";
                    break;
                case "Theon":
                    curChap.house = "Greyjoy";
                    break;
                case "Victarion Greyjoy":
                    curChap.house = "Greyjoy";
                    break;
                case "Arianne Martell":
                    curChap.house = "Martell";
                    break;
                case "Arya":
                    curChap.house = "Stark";
                    break;
                case "Arys Oakheart":
                    curChap.house = "Misc";
                    break;
                case "Hotah":
                    curChap.house = "Martell";
                    break;
                case "Bran":
                    curChap.house = "Stark";
                    break;
                case "Brienne":
                    curChap.house = "Misc";
                    break;
                case "Catelyn":
                    curChap.house = "Stark";
                    break;
                case "Cersei":
                    curChap.house = "Lannister";
                    break;
                case "Daenerys":
                    curChap.house = "Targaryen";
                    break;
                case "Davos":
                    curChap.house = "Baratheon";
                    break;
                case "Eddard":
                    curChap.house = "Stark";
                    break;
                case "Jaime":
                    curChap.house = "Lannister";
                    break;
                case "Jon":
                    curChap.house = "Night's Watch";
                    break;
                case "Martell":
                    curChap.house = "Martell";
                    break;
                case "Prologue":
                    curChap.house = "Misc";
                    break;
                case "Samwell":
                    curChap.house = "Night's Watch";
                    break;
                case "Sansa":
                    curChap.house = "Stark";
                    break;
                case "Theon":
                    curChap.house = "Greyjoy";
                    break;
                case "Tyrion":
                    curChap.house = "Lannister";
                    break;
                case "Victarion":
                    curChap.house = "Greyjoy";
                    break;
                case "Epilogue":
                    curChap.house = "Misc";
                    break;
                case "Quentyn":
                    curChap.house = "Martell";
                    break;
                case "Aegon":
                    curChap.house = "Targaryen";
                    break;
                case "Melisandre":
                    curChap.house = "Baratheon";
                    break;
                case "Doran":
                    curChap.house = "Martell";
                    break;
                case "Barristan Selmy":
                    curChap.house = "Targaryen";
                    break;
                default:
                    curChap.house = "Misc";
                    break;
            }            
          }

          for(int i = 0; i < chapters.length; i++)
          {
            Chapter curChap = chapters[i];
            switch(curChap.house){
                case "Misc":
                    curChap.houseColor = miscColor;
                    curChap.hasSigil = false;
                    break;
                case "Stark":
                    curChap.houseColor = starkColor;
                    curChap.sigil = "StarkSigil.png";
                    break;
                case "Targaryen":
                    curChap.houseColor = targColor;
                    curChap.sigil = "TargSigil.png";
                    break;
                case "Night's Watch":
                    curChap.houseColor = nightColor;
                    curChap.sigil = "NightsWatchSigil.png";
                    break;
                case "Lannister":
                    curChap.houseColor = lannisterColor;
                    curChap.sigil = "LannisterSigil.png";
                    break;
                case "Baratheon":
                    curChap.houseColor = baratheonColor;        
                    curChap.sigil = "BaratheonSigil.png";
                    break;
                case "Greyjoy":
                    curChap.houseColor = greyjoyColor;        
                    curChap.sigil = "GreyjoySigil.png";
                    break;
                case "Martell":
                    curChap.houseColor = martellColor;
                    curChap.hasSigil = false;
                    break;
                }                
            }
          };
    </script>
    </body>
</html>